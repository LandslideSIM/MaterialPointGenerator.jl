var documenterSearchIndex = {"docs":
[{"location":"example/DEM/#DEM","page":"DEM","title":"DEM","text":"","category":"section"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"Here we use a function to generate a DEM sample file:","category":"page"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"using MaterialPointGenerator\n\nxy = meshbuilder(0:0.1:10, 0:0.1:10)\nz = @. cos(xy[:, 1]) * sin(xy[:, 2])\ndata = [xy z]","category":"page"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"We can visualize data and obtain:","category":"page"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"(Image: image5)","category":"page"},{"location":"example/DEM/#Fill-to-the-plane","page":"DEM","title":"Fill to the plane","text":"","category":"section"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"h = 0.2\nbottom = -1.0\n\ndem_0 = data\ndem_1 = rasterizeDEM(dem_0, h)\n\npts = dem2particle(dem_1, h, bottom)","category":"page"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"(Image: image6)","category":"page"},{"location":"example/DEM/#Fill-to-the-plane-with-material-id","page":"DEM","title":"Fill to the plane with material id","text":"","category":"section"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"h = 0.2\nbottom = -1.0\n\ndem_0 = data\ndem_1 = rasterizeDEM(dem_0, h)\n\nlayer1 = data1\nlayer2 = data2\n\nlayer = [layer1, layer2]\n\npts, nid = dem2particle(dem_1, h, bottom, layer)","category":"page"},{"location":"example/DEM/#Fill-to-another-DEM","page":"DEM","title":"Fill to another DEM","text":"","category":"section"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"h = 0.2\n\ndem_0 = data\ndem_t = rasterizeDEM(dem_0, h)\ndem_b = copy(dem_1)\ndem_b[:, 3] .-= 2\n\npts = dem2particle(dem_t, h, dem_b)","category":"page"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"(Image: image7)","category":"page"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"(Image: image8)","category":"page"},{"location":"example/DEM/#Fill-to-another-DEM-with-material-id","page":"DEM","title":"Fill to another DEM with material id","text":"","category":"section"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"h = 0.2\n\ndem_0 = data\ndem_t = rasterizeDEM(dem_0, h)\ndem_b = copy(dem_1)\ndem_b[:, 3] .-= 2\n\nlayer1 = data1 # material surface\nlayer2 = data2 # material surface\n\nlayer = [layer1, layer2]\n\npts, nid = dem2particle(dem_t, h, dem_b, layer)","category":"page"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"(Image: image9)","category":"page"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"profile:","category":"page"},{"location":"example/DEM/","page":"DEM","title":"DEM","text":"(Image: image10)","category":"page"},{"location":"example/polyhedron/#Polyhedron","page":"Polyhedron","title":"Polyhedron","text":"","category":"section"},{"location":"example/polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"note: Note\nAll example files can be found at assets/3d_simple https://github.com/LandslideSIM/MaterialPointGenerator.jl.","category":"page"},{"location":"example/polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"Here, we only need to provide the .stl file and specify the cell size h.","category":"page"},{"location":"example/polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"using MaterialPointGenerator\n\nsrc_dir     = joinpath(@__DIR__, \"assets/3d_simple\")\nstl_file    = joinpath(src_dir, \"wedge.stl\")\noutput_file = joinpath(src_dir, \"3d_simple.xyz\")\n\npolyhedron2particle(stl_file, output_file, 0.5, verbose=true)","category":"page"},{"location":"example/polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"(Image: image3)","category":"page"},{"location":"example/polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"A partially enlarged image:","category":"page"},{"location":"example/polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"(Image: image4)","category":"page"},{"location":"workflow/polyhedron/#Polyhedron","page":"Polyhedron","title":"Polyhedron","text":"","category":"section"},{"location":"workflow/polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"In addition to the standard 3D model, we recommend obtaining a surface model file directly through other preprocessing software (there is no need for mesh discretization within the model). Using this STL file, we will voxelize it and fill it with uniform material points.","category":"page"},{"location":"workflow/polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"polyhedron2particle(\n    stl_file   ::String, \n    output_file::String, \n    h          ::Real; \n    method     ::String=\"voxel\",\n    verbose    ::Bool  =false\n)","category":"page"},{"location":"workflow/polyhedron/#MaterialPointGenerator.polyhedron2particle-Tuple{String, String, Real}","page":"Polyhedron","title":"MaterialPointGenerator.polyhedron2particle","text":"polyhedron2particle(stl_file::String, output_file, h; method::String=\"voxel\", \n    verbose::Bool=false)\n\nDescription:\n\nConvert a polyhedron (.stl) to a set of particles. The function will write the populated  particles of each voxel into a .xyz file. The voxel size is defined by h, it is suggest to be equal to the MPM background grid size. method can be \"voxel\" or \"ray\" in string.The  verbose is a flag to show the time consumption of each step.\n\nExample:\n\nstl_file = \"/path/to/your/model.stl\"\noutput_file = \"/path/to/your/model.xyz\"\nh = 0.1\npolyhedron2particle(stl_file, output_file, h, verbose=true)\n\n\n\n\n\n","category":"method"},{"location":"workflow/polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"Note that h refers to the size of the grid in the MPM simulation. By default, we will fill each cell with 8 material points.","category":"page"},{"location":"workflow/polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"The method about \"ray\" is modified based on this work: https://link.springer.com/article/10.1007/s40571-024-00813-z.","category":"page"},{"location":"workflow/simple_mesh/#Simple-Mesh","page":"Simple Mesh","title":"Simple Mesh","text":"","category":"section"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"Here, we consider generating rectangular domain nodes (2D) and cuboidal domain nodes (3D) by controlling the starting range and step size in each direction.","category":"page"},{"location":"workflow/simple_mesh/#2D","page":"Simple Mesh","title":"2D","text":"","category":"section"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"Consider a rectangular area where the range in the x-direction is from 0 to 10 and in the  y-direction from 0 to 6. The step size in the x-direction is 1, and in the y-direction, it  is 2. Therefore, we can do:","category":"page"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"meshbuilder(x::T, y::T; ϵ::String=\"FP64\") where T <: AbstractRange","category":"page"},{"location":"workflow/simple_mesh/#MaterialPointGenerator.meshbuilder-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractRange","page":"Simple Mesh","title":"MaterialPointGenerator.meshbuilder","text":"meshbuilder(x::T, y::T; ϵ::String=\"FP64\") where T <: AbstractRange\n\nDescription:\n\nGenerate structured mesh in 2D space.\n\n\n\n\n\n","category":"method"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"julia> pts = meshbuilder(0.0 : 1.0 : 10.0, 0.0: 2.0 : 6.0)\n44×2 Matrix{Float64}:\n  0.0  0.0\n  0.0  2.0\n  0.0  4.0\n  0.0  6.0\n  1.0  0.0\n  1.0  2.0\n  ⋮    \n  9.0  6.0\n 10.0  0.0\n 10.0  2.0\n 10.0  4.0\n 10.0  6.0","category":"page"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"This way, we can obtain the results shown in the figure. The variable pts is an array  where the first column contains the x-coordinates of all the nodes, and the second column  contains the corresponding y-coordinates.","category":"page"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"(Image: Image1)","category":"page"},{"location":"workflow/simple_mesh/#3D","page":"Simple Mesh","title":"3D","text":"","category":"section"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"Similarly, we can use this function to generate a set of points in three-dimensional space.","category":"page"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"meshbuilder(x::T, y::T, z::T; ϵ::String=\"FP64\") where T <: AbstractRange","category":"page"},{"location":"workflow/simple_mesh/#MaterialPointGenerator.meshbuilder-Union{Tuple{T}, Tuple{T, T, T}} where T<:AbstractRange","page":"Simple Mesh","title":"MaterialPointGenerator.meshbuilder","text":"meshbuilder(x::T, y::T, z::T; ϵ::String=\"FP64\") where T <: AbstractRange\n\nDescription:\n\nGenerate structured mesh in 3D space.\n\n\n\n\n\n","category":"method"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"julia> pts = meshbuilder(0.0 : 1.0 : 10.0, 0.0: 2.0 : 6.0, 0.0 : 2.0 : 4.0)\n132×3 Matrix{Float64}:\n  0.0  0.0  0.0\n  0.0  2.0  0.0\n  0.0  4.0  0.0\n  0.0  6.0  0.0\n  1.0  0.0  0.0\n  1.0  2.0  0.0\n  ⋮         \n  9.0  6.0  4.0\n 10.0  0.0  4.0\n 10.0  2.0  4.0\n 10.0  4.0  4.0\n 10.0  6.0  4.0","category":"page"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"(Image: Image2)","category":"page"},{"location":"workflow/simple_mesh/#Export","page":"Simple Mesh","title":"Export","text":"","category":"section"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"For two-dimensional points and three-dimensional points, you can use the functions savexy and savexyz to save them as .xy and .xyz files, respectively. You can also use readxy and readxyz to read these files.","category":"page"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"savexy(file_dir::P, pts::T) where {P <: String, T <: AbstractMatrix}\nsavexyz(file_dir::P, pts::T) where {P <: String, T <: AbstractMatrix}\nreadxy(file_dir::P) where P <: String\nreadxyz(file_dir::P) where P <: String","category":"page"},{"location":"workflow/simple_mesh/#MaterialPointGenerator.savexy-Union{Tuple{T}, Tuple{P}, Tuple{P, T}} where {P<:String, T<:(AbstractMatrix)}","page":"Simple Mesh","title":"MaterialPointGenerator.savexy","text":"savexy(file_dir::P, pts::T) where {P <: String, T <: AbstractMatrix}\n\nDescription:\n\nSave the 2D points pts to the .xy file (file_dir).\n\n\n\n\n\n","category":"method"},{"location":"workflow/simple_mesh/#MaterialPointGenerator.savexyz-Union{Tuple{T}, Tuple{P}, Tuple{P, T}} where {P<:String, T<:(AbstractMatrix)}","page":"Simple Mesh","title":"MaterialPointGenerator.savexyz","text":"savexyz(file_dir::P, pts::T) where {P <: String, T <: AbstractMatrix}\n\nDescription:\n\nSave the 3D points pts to the .xyz file (file_dir).\n\n\n\n\n\n","category":"method"},{"location":"workflow/simple_mesh/#MaterialPointGenerator.readxy-Tuple{P} where P<:String","page":"Simple Mesh","title":"MaterialPointGenerator.readxy","text":"readxy(file_dir::P) where P <: String\n\nDescription:\n\nRead the 2D .xy file from file_dir.\n\n\n\n\n\n","category":"method"},{"location":"workflow/simple_mesh/#MaterialPointGenerator.readxyz-Tuple{P} where P<:String","page":"Simple Mesh","title":"MaterialPointGenerator.readxyz","text":"readxyz(file_dir::P) where P <: String\n\nDescription:\n\nRead the 3D .xyz file from file_dir.\n\n\n\n\n\n","category":"method"},{"location":"workflow/simple_mesh/","page":"Simple Mesh","title":"Simple Mesh","text":"output_file = joinpath(@__DIR__, \"test.xyz\")\nsavexyz(output_file, pts)\ndata = readxyz(output_file)","category":"page"},{"location":"example/polygon/#Polygon","page":"Polygon","title":"Polygon","text":"","category":"section"},{"location":"example/polygon/","page":"Polygon","title":"Polygon","text":"note: Note\nAll example files can be found at assets/2d_nid https://github.com/LandslideSIM/MaterialPointGenerator.jl.","category":"page"},{"location":"example/polygon/","page":"Polygon","title":"Polygon","text":"First, we obtained the .stl and .msh files of the model through Gmsh. The .msh file is used to identify the partition information within the model.","category":"page"},{"location":"example/polygon/","page":"Polygon","title":"Polygon","text":"using MaterialPointGenerator\n\nsrc_dir     = joinpath(@__DIR__, \"assets/2d_nid\")\nstl_file    = joinpath(src_dir , \"2d_nid.stl\")\nmsh_file    = joinpath(src_dir , \"2d_nid.msh\")\nnid_file    = joinpath(src_dir , \"2d_nid.nid\")\noutput_file = joinpath(src_dir , \"2d_nid.xy\")\n\npolygon2particle(stl_file, msh_file, output_file, nid_file, 0.001, verbose=true)","category":"page"},{"location":"example/polygon/","page":"Polygon","title":"Polygon","text":"Note that this will generate two files, namely .nid and .xy. We can visualize this result to obtain the following outcome:","category":"page"},{"location":"example/polygon/","page":"Polygon","title":"Polygon","text":"(Image: image1)","category":"page"},{"location":"example/polygon/","page":"Polygon","title":"Polygon","text":"In this example, we have a total of three partitions. A partially enlarged image:","category":"page"},{"location":"example/polygon/","page":"Polygon","title":"Polygon","text":"(Image: image1)","category":"page"},{"location":"workflow/DEM/#DEM","page":"DEM","title":"DEM","text":"","category":"section"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"note: Note\nHere we assume that the DEM file only includes the three-dimensional coordinates of points.  The input format for the DEM is a three-column array, where the first column represents the x-coordinate, the second column represents the corresponding y-coordinate, and the third  column is the z-coordinate.","category":"page"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"The Digital Elevation Model (DEM) is a special 3D case. Typically, for landslide simulations, we obtain a DEM file composed of surface data, which consists of three-dimensional scatter points, with each x-y coordinate corresponding to a unique z value. Before generating the material points, we need to perform a simple processing step by rasterizing it on the x-y plane using inverse distance weighting (IDW). We then proceed to generate the material points based on our requirements.","category":"page"},{"location":"workflow/DEM/#DEM-file-pre-processing","page":"DEM","title":"DEM file pre-processing","text":"","category":"section"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"The DEM file is a simple three-column array. Each DEM must be rasterized to ensure it is structured (regular) in the x-y plane.","category":"page"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"rasterizeDEM(\n    dem       ::Matrix{T2},\n    h         ::T2; \n    k         ::T1        = 10, \n    p         ::T1        = 2, \n    trimbounds::Matrix{T2}= [0.0 0.0], \n    dembounds ::Vector{T2}= [0.0, 0.0]\n) where {T1, T2}","category":"page"},{"location":"workflow/DEM/#MaterialPointGenerator.rasterizeDEM-Union{Tuple{T2}, Tuple{T1}, Tuple{Matrix{T2}, T2}} where {T1, T2}","page":"DEM","title":"MaterialPointGenerator.rasterizeDEM","text":"rasterizeDEM(dem, h; k=10, p=2, trimbounds=[0.0 0.0], dembounds=[0.0, 0.0])\n\nDescription:\n\nRasterize the DEM file to generate particles. dem is a coordinates Array with three  columns (x, y, z). h is the space of the cloud points in x and y directions,  normally it is equal to the grid size in the MPM simulation. k is the number of nearest  neighbors (10 by default), p is the power parameter (2 by default), trimbounds is the  boundary of the particles, dembounds is the boundary of the DEM.\n\n\n\n\n\n","category":"method"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"Through this function, we can rasterize the input DEM file and specify the spacing between each point (which is the same as the grid size in the MPM simulation). The trimbounds parameter is used to define the shape of the DEM file in the x-y plane; it is a two-dimensional array where each row represents a vertex of the shape in the x-y plane. The dembounds parameter can be used to specify the range of the DEM in the x-y plane; it is a vector that represents [xmin, xmax, ymin, ymax]. This can be utilized to process two DEMs of the same area at different times, ensuring they have completely consistent x-y coordinates.","category":"page"},{"location":"workflow/DEM/#DEM-with-a-flat-bottom-surface","page":"DEM","title":"DEM with a flat bottom surface","text":"","category":"section"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"Suppose we have a DEM and we want to close it with a base plane, for example, at z=0.","category":"page"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"dem2particle(\n    dem   ::Matrix{T2}, \n    h     ::T2, \n    bottom::T2\n) where T2","category":"page"},{"location":"workflow/DEM/#MaterialPointGenerator.dem2particle-Union{Tuple{T2}, Tuple{Matrix{T2}, T2, T2}} where T2","page":"DEM","title":"MaterialPointGenerator.dem2particle","text":"dem2particle(dem, h, bottom)\n\nDescription:\n\nGenerate particles from a given DEM file. dem is a coordinates Array with three columns  (x, y, z). h is the space of particles in z direction, normally it is equal to the grid  size in the MPM simulation. bottom is a value, which means the plane z = bottom.\n\n\n\n\n\n","category":"method"},{"location":"workflow/DEM/#DEM-with-a-given-bottom-surface","page":"DEM","title":"DEM with a given bottom surface","text":"","category":"section"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"If the base used to close DEM-1 is not a flat surface, we can designate another DEM-2 to serve as the base for closing DEM-1.","category":"page"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"dem2particle(\n    dem   ::Matrix{T2}, \n    h     ::T2, \n    bottom::Matrix{T2}\n) where T2","category":"page"},{"location":"workflow/DEM/#MaterialPointGenerator.dem2particle-Union{Tuple{T2}, Tuple{Matrix{T2}, T2, Matrix{T2}}} where T2","page":"DEM","title":"MaterialPointGenerator.dem2particle","text":"dem2particle(dem, h, bottom)\n\nDescription:\n\nGenerate particles from a given DEM file and a bottom surface file. dem is a coordinates  Array with three columns (x, y, z), which has to be initialized with the struct DEMSurface.  bottom::DEMSurface should have the same x and y coordinates as the DEM, and the z value should be lower than the dem. h is the space of grid size in z direction used in the MPM simulation.\n\n\n\n\n\n","category":"method"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"info: Info\nDEM-2 and DEM-1 should have exactly the same coordinates in the x-y plane. This can be achieved using rasterizeDEM.","category":"page"},{"location":"workflow/DEM/#Advanced","page":"DEM","title":"Advanced","text":"","category":"section"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"Here, we consider attaching geological structures (material properties) to the filled material points. The output of this workflow consists of two files: the first, as before, is a 3D scatter coordinate file in .xyz format, and the second is a material ID file (.nid) with the same number of points as the scatter file.","category":"page"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"To prepare for this, you need to have layered surface files in DEM format, which should have exactly the same x-y coordinates as the input DEM surface file (this can be achieved using parameters a and b). They should look like the following:","category":"page"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"(Image: image4)","category":"page"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"dem2particle(\n    dem   ::Matrix{T2}, \n    h     ::T2, \n    bottom::T2,\n    layer ::Vector{Matrix{T2}}\n) where T2","category":"page"},{"location":"workflow/DEM/#MaterialPointGenerator.dem2particle-Union{Tuple{T2}, Tuple{Matrix{T2}, T2, T2, Array{Matrix{T2}, 1}}} where T2","page":"DEM","title":"MaterialPointGenerator.dem2particle","text":"dem2particle(dem, h, bottom, layer)\n\nDescription:\n\nGenerate particles from a given DEM file and a bottom value (flat bottom surface). dem is  a coordinates Array with three columns (x, y, z), and the bottom value should be lower than the dem. h is the space of grid size in z direction used in the MPM simulation. layer is a Vector of Matrix with three columns (x, y, z), which represents the layer surfaces. Note that layers are sorted from top to bottom.\n\n\n\n\n\n","category":"method"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"Assuming that we have processed each layered DEM(s), they should be saved in the layer Vector in order from top to bottom along the z-direction as input. Please refer to the usage in the Example section.","category":"page"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"This workflow also supports the case where a bottom DEM is provided:","category":"page"},{"location":"workflow/DEM/","page":"DEM","title":"DEM","text":"dem2particle(\n    dem   ::Matrix{T2}, \n    h     ::T2, \n    bottom::Matrix{T2},\n    layer ::Vector{Matrix{T2}}\n) where T2","category":"page"},{"location":"workflow/DEM/#MaterialPointGenerator.dem2particle-Union{Tuple{T2}, Tuple{Matrix{T2}, T2, Matrix{T2}, Array{Matrix{T2}, 1}}} where T2","page":"DEM","title":"MaterialPointGenerator.dem2particle","text":"dem2particle(dem, h, bottom, layer)\n\nDescription:\n\nGenerate particles from a given DEM file and a bottom surface file. dem is a coordinates Array with three columns (x, y, z), and the z value should be lower than the dem. h is  the space of grid size in z direction used in the MPM simulation. layer is a Vector of  Matrix with three columns (x, y, z), which represents the layer surfaces. Note that layers  are sorted from top to bottom.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"During the EGU2023 conference, when I presented a high-performance MPM  (Material Point Method) solver, I was asked,  \"How do you discretize the computational model for the MPM?\" I didn't have a clear answer (I didn't even consider it a problem) because the models were relatively simple and could be generated directly using some straightforward functions. However, as computational models gradually became more complex and diverse, I began to realize that this was indeed a very good question. The preprocessing for MPM should not be a computationally intensive task; it should be fast enough. Yet, I couldn't find a \"plug-and-play\" generalized code for this purpose. Some literatures have contributed to this issue, and I built upon their work to create a comprehensive and refined julia package. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"No parallelization, no problem—5,334,808 particles from an STL file (998,137 triangles) in just 0.6 s Intel(R) Core(TM) i9-10900K CPU @ 3.70GHz","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Just type ] in Julia's  REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\n(@1.11) Pkg> add MaterialPointGenerator","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Structured (regular) coordinates\nSupport complicated 2/3D models\nParticle generation from a Digital Elevation Model (DEM) file  \nAutomatically interpolate DEM files with support for shape trimming.","category":"page"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is sponserd by Risk Group | Université de Lausanne and China Scholarship Council [中国国家留学基金管理委员会].","category":"page"},{"location":"utils/#Useful-tools","page":"Useful tools","title":"Useful tools","text":"","category":"section"},{"location":"utils/","page":"Useful tools","title":"Useful tools","text":"fastvtp(coords; vtp_file=\"output.vtp\", data::T=NamedTuple()) where T <: NamedTuple\nsortbycol(pts, col::T) where T <: Int\ncsv2geo2d(csv_file::String, geo_file::String)\nsort_pts(pts::Matrix)\nsort_pts_xy\npopulate_pts(pts_cen::Matrix{T}, h::T) where T","category":"page"},{"location":"utils/#MaterialPointGenerator.fastvtp-Union{Tuple{Any}, Tuple{T}} where T<:NamedTuple","page":"Useful tools","title":"MaterialPointGenerator.fastvtp","text":"fastvtp(coords; vtp_file=\"output.vtp\", data::T=NamedTuple())\n\nDescription:\n\nGenerates a .vtp file by passing custom fields.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MaterialPointGenerator.sortbycol-Union{Tuple{T}, Tuple{Any, T}} where T<:Int64","page":"Useful tools","title":"MaterialPointGenerator.sortbycol","text":"sortbycol(pts, col::T) where T <: Int\n\nDescription:\n\nSort the points in pts according to the column col.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MaterialPointGenerator.csv2geo2d-Tuple{String, String}","page":"Useful tools","title":"MaterialPointGenerator.csv2geo2d","text":"csv2geo2d(csv_file::String, geo_file::String)\n\nDescription:\n\nConvert the CSV file (.csv) to the Gmsh geo (.geo) file.\n\n\n\n\n\n","category":"method"},{"location":"utils/#MaterialPointGenerator.sort_pts-Tuple{Matrix}","page":"Useful tools","title":"MaterialPointGenerator.sort_pts","text":"sort_pts(pts::Matrix)\n\nDescription:\n\nSort the points in pts by the (z-), y-, and x-coordinates, in that order (2/3D).\n\n\n\n\n\n","category":"method"},{"location":"utils/#MaterialPointGenerator.sort_pts_xy","page":"Useful tools","title":"MaterialPointGenerator.sort_pts_xy","text":"sort_pts_xy(pts::Matrix)\n\nDescription:\n\nSort the points in pts by the x- and y-coordinates, in that order.\n\n\n\n\n\n","category":"function"},{"location":"utils/#MaterialPointGenerator.populate_pts-Union{Tuple{T}, Tuple{Matrix{T}, T}} where T","page":"Useful tools","title":"MaterialPointGenerator.populate_pts","text":"populate_pts(pts_cen, h)\n\nDescription:\n\nPopulate the points around the center points pts_cen with the spacing h/4 (2/3D).\n\n\n\n\n\n","category":"method"},{"location":"workflow/polygon/#Polygon","page":"Polygon","title":"Polygon","text":"","category":"section"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"For the two-dimensional polygon model, we consider two cases: 1) simple polygons, which have no holes in their interior, and 2) complex arbitrary polygons.","category":"page"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"For the first scenario, we simply need to input the vertices of the polygon in a counterclockwise order, and then MaterialPointGenerator.jl will automatically generate uniform material points of the specified size within the minimum enclosing rectangle (AABB) of the polygon. It will use the winding number algorithm to determine whether each material point is inside the polygon. This process does not take much time for simple polygons, and we have enabled multithreading by default (make sure to configure the correct number of threads when starting Julia).","category":"page"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"For the second scenario, to support complex polygons in any situation, we need to utilize some preprocessing software. Here, we recommend using Gmsh, which is not only open-source and powerful but also offers a user-friendly GUI, making it very easy to get started. We first create the model in Gmsh, where we can determine the precision of the triangular mesh according to our needs (there are many tutorials on Gmsh available on YouTube). After that, we export it as a .stl file. While other formats can theoretically be used, we always recommend sticking with the .stl format. Next, you simply need to read this file and specify the grid size (the grid size in MPM simulations), which is very straightforward!","category":"page"},{"location":"workflow/polygon/#Simple-2D-model","page":"Polygon","title":"Simple 2D model","text":"","category":"section"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"We are preparing to discretize a two-dimensional pentagon, noting that the specified distance is between the material points in both the x and y directions.","category":"page"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"polygon2particle(polygon, lpx, lpy)","category":"page"},{"location":"workflow/polygon/#MaterialPointGenerator.polygon2particle-Tuple{Any, Any, Any}","page":"Polygon","title":"MaterialPointGenerator.polygon2particle","text":"polygon2particle(polygon, lpx, lpy)\n\nDescription:\n\nGenerate structured particles from a given polygon. Note the vertices of the polygon should  be ordered in a counterclockwise manner; otherwise, it may lead to incorrect results.  \n\nlpx and lpy are the space of particles in x and y directions, respectively.\n\npolygon is the polygon, for example, polygon = [0 0; 2 0; 2 1; 0 1] means generate structured particles in a rectangle area.\n\n\n\n\n\n","category":"method"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"julia> polygon = [0.3 0.0; 0.8 0.0; 1.1 0.5; 0.55 0.8; 0.0 0.5]\njulia> pts = polygon2particle(polygon, 0.01, 0.01)\n223×2 Matrix{Float64}:\n 0.03  0.49\n 0.08  0.39\n 0.08  0.44\n 0.08  0.49\n 0.08  0.54\n 0.13  0.29\n ⋮     \n 0.98  0.54\n 1.03  0.39\n 1.03  0.44\n 1.03  0.49\n 1.08  0.49","category":"page"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"(Image: image3)","category":"page"},{"location":"workflow/polygon/#Arbitrary-2D-model","page":"Polygon","title":"Arbitrary 2D model","text":"","category":"section"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"Please use pre-processing tools like Gmsh or MeshLab to ensure that the current mesh is closed in advance.","category":"page"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"polygon2particle(stl_file::String, output_file::String, h; verbose::Bool=true)","category":"page"},{"location":"workflow/polygon/#MaterialPointGenerator.polygon2particle-Tuple{String, String, Any}","page":"Polygon","title":"MaterialPointGenerator.polygon2particle","text":"polygon2particle(stl_file, output_file, h; verbose=true)\n\nDescription:\n\nGenerate structured particles from a given .stl file. The particles are generated by voxelizing the 2D space of the STL model. The voxel size h should be positive.\n\n\n\n\n\n","category":"method"},{"location":"workflow/polygon/#Advanced","page":"Polygon","title":"Advanced","text":"","category":"section"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"This involves some advanced operations for partitioning the generated material points. There are two ways to achieve this: 1) directly determining whether the current material point is within a specified polygonal area, and 2) using the concept of physical groups in Gmsh to differentiate the model during the meshing phase. ","category":"page"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"For the first case, we can utilize a practical function to check if a point is inside the polygon. ","category":"page"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"particle_in_polygon(px::T, py::T, polygon) where T","category":"page"},{"location":"workflow/polygon/#MaterialPointGenerator.particle_in_polygon-Union{Tuple{T}, Tuple{T, T, Any}} where T","page":"Polygon","title":"MaterialPointGenerator.particle_in_polygon","text":"particle_in_polygon(px, py, polygon)\n\nDescription:\n\nDetermine whether a point is inside a polygon. Note the vertices of the polygon should be       ordered in a counterclockwise manner; otherwise, it may lead to incorrect results.  \n\n(This function is generated by ChatGPT 4o - 2024.10.10)\n\n\n\n\n\n","category":"method"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"For the second case, in addition to the .stl file, we also need to provide a .msh file.","category":"page"},{"location":"workflow/polygon/","page":"Polygon","title":"Polygon","text":"polygon2particle(\n    stl_file   ::String, \n    msh_file   ::String, \n    output_file::String,\n    nid_file   ::String,\n    h; \n    verbose    ::Bool=true\n)","category":"page"},{"location":"workflow/polygon/#MaterialPointGenerator.polygon2particle-Tuple{String, String, String, String, Any}","page":"Polygon","title":"MaterialPointGenerator.polygon2particle","text":"polygon2particle(stl_file, msh_file, output_file, nid_file, h; verbose=true)\n\nDescription:\n\nGenerate structured particles from a given .stl file and .msh file. The particles are generated by voxelizing the 2D space of the STL model. The voxel size h should be positive.\n\n\n\n\n\n","category":"method"}]
}
