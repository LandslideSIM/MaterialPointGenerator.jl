import{_ as a,c as t,o as i,aA as s}from"./chunks/framework.CyuDMGfi.js";const u=JSON.parse('{"title":"Get Started","description":"","frontmatter":{},"headers":[],"relativePath":"getstarted.md","filePath":"getstarted.md","lastUpdated":null}'),r={name:"getstarted.md"};function n(l,e,o,d,p,h){return i(),t("div",null,e[0]||(e[0]=[s(`<h1 id="Get-Started" tabindex="-1">Get Started <a class="header-anchor" href="#Get-Started" aria-label="Permalink to &quot;Get Started {#Get-Started}&quot;">​</a></h1><p>During the EGU2023 conference, when I presented a high-performance MPM (Material Point Method) solver, I was asked, &quot;How do you discretize the computational model for the MPM?&quot; I didn&#39;t have a clear answer (I didn&#39;t even consider it a problem) because the models were relatively simple and could be generated directly using some straightforward functions. However, as computational models gradually became more complex and diverse, I began to realize that this was indeed a very good question. The preprocessing for MPM should not be a computationally intensive task; it should be fast enough. Yet, I couldn&#39;t find a &quot;plug-and-play&quot; generalized code for this purpose. Some literatures have contributed to this issue, and I built upon their work to create a comprehensive and refined julia package.</p><blockquote><p>No parallelization, no problem—5,334,808 particles from an STL file (998,137 triangles) in just 0.6 s Intel(R) Core(TM) i9-10900K CPU @ 3.70GHz</p></blockquote><h2 id="installation" tabindex="-1">Installation <a class="header-anchor" href="#installation" aria-label="Permalink to &quot;Installation&quot;">​</a></h2><p>Just type <code>]</code> in Julia&#39;s <code>REPL</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) Pkg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> add MaterialPointGenerator</span></span></code></pre></div><h2 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-label="Permalink to &quot;Features&quot;">​</a></h2><ul><li><p>Structured (regular) coordinates</p></li><li><p>Support complicated 2/3D models</p></li><li><p>Particle generation from a Digital Elevation Model (DEM) file</p></li><li><p>Automatically interpolate DEM files with support for shape trimming.</p></li></ul><h2 id="acknowledgement" tabindex="-1">Acknowledgement <a class="header-anchor" href="#acknowledgement" aria-label="Permalink to &quot;Acknowledgement&quot;">​</a></h2><p>This project is sponserd by <a href="https://wp.unil.ch/risk/" target="_blank" rel="noreferrer">Risk Group | Université de Lausanne</a> and <a href="https://www.csc.edu.cn/" target="_blank" rel="noreferrer">China Scholarship Council [中国国家留学基金管理委员会]</a>.</p>`,10)]))}const k=a(r,[["render",n]]);export{u as __pageData,k as default};
