#==========================================================================================+
|        MaterialPointGenerator.jl: Generate structured material particles in Julia        |
+------------------------------------------------------------------------------------------+
|  File Name  : polygon.jl                                                                 |
|  Description: Generate structured mesh in 2D space by a given polygon                    |
|  Programmer : Zenan Huo                                                                  |
|  Start Date : 01/01/2022                                                                 |
|  Affiliation: Risk Group, UNIL-ISTE                                                      |
|  Functions  : 01. particle_in_polygon                                                    |
|               02. polygon2particle                                                       |
+==========================================================================================#

export particle_in_polygon
export polygon2particle

"""
    particle_in_polygon(polygon, px, py)

Description:
---
Determine whether a point [px, py] is inside a polygon. Note the vertices of the polygon 
should be ordered in a **counterclockwise** manner, it is better to use the function 
`getpolygon` to get it; otherwise, it may lead to incorrect results.

Example:
---
```julia
polygon = [0 0; 2 0; 2 1; 0 1]
particle_in_polygon(polygon, 0.5, 0.1) # check points (0.5, 0.1)
```
"""
@views function particle_in_polygon(
    polygon::AbstractMatrix{T}, 
    px     ::Real, 
    py     ::Real
) where T<:Real
    # inputs check
    n, m = size(polygon)
    n < 3 && error("polygon should have at least 3 vertices")
    m == 2 || error("polygon should be a Nx2 array")
    
    # convert to python objects
    py_polygon = Polygon(polygon)

    # check if the particle is inside the polygon
    rst = contains_xy(py_polygon, px, py)

    return pyconvert(Bool, rst.item())
end

"""
    particle_in_polygon(polygon, points)

Description:
---
Determine whether a point set is inside a polygon. 

- `polygon` is a Nx2 array. Note the vertices of the polygon should be ordered in a 
**counterclockwise** manner, it is better to use the function `getpolygon` to get it; 
otherwise, it may lead to incorrect results.
- `points` is a Nx2 array, where N is the number of points to be checked.

Example:
---
```julia
polygon = [0 0; 2 0; 2 1; 0 1]
points = [0.5 0.1; 1.5 0.5; 2.5 0.5]
particle_in_polygon(polygon, points) # check points (0.5, 0.1), (1.5, 0.5), (2.5, 0.5)
```
"""
@views function particle_in_polygon(
    polygon::AbstractMatrix{T1}, 
    points ::AbstractMatrix{T2}
) where {T1<:Real, T2<:Real}
    # inputs check for polygon
    n, m = size(polygon)
    n < 3 && error("polygon should have at least 3 vertices")
    m == 2 || error("polygon should be a Nx2 array")
    # inputs check for points
    n, m = size(points)
    n ≥ 1 || error("points should have at least 1 point")
    m == 2 || error("points should be a Nx2 array")

    # convert to python objects
    py_polygon = Polygon(polygon)
    py_points = shapely.points(points)
    
    # check if the particle is inside the polygon
    rst = shapely.contains(py_polygon, py_points)

    return pyconvert(Vector{Bool}, rst)
end

"""
    particle_in_polygon(stl_file, points)

Description:
---
Determine whether a point set is inside a polygon defined by a 3D STL file. The STL file is
a 2D (z=0) model. The points are given as a Nx2 array, where N is the number of points to be
checked.

Example:
---
```julia
stl_file = "path/to/your/model.stl"
points = [0.5 0.1; 1.5 0.5; 2.5 0.5]
particle_in_polygon(stl_file, points) # check points (0.5, 0.1), (1.5, 0.5), (2.5, 0.5)
```
"""
@views function particle_in_polygon(
    stl_file::String, 
    points  ::AbstractMatrix{T}
) where T<:Real
    size(points, 2) == 2 || error("points must be 2D coordinates (N, 2)")
    py_points = shapely.points(points)
    @pyexec """
    def py_pip2(stl_file, py_points, trimesh, shapely, Polygon, unary_union):

        mesh = trimesh.load(stl_file, force='mesh')   # → (n_tri, 3, 3)
        tris2d = mesh.triangles[:, :, :2]               # 取 X-Y

        # 2) 把每个三角形变成 Shapely Polygon
        region = unary_union([Polygon(t) for t in tris2d])

        # 3) 向量化包含测试
        mask = shapely.contains(region, py_points)

        return mask
    """ => py_pip2
    tmp = py_pip2(stl_file, py_points, trimesh, shapely, Polygon, unary_union)
    return pyconvert(Vector{Bool}, tmp)
end

# """
#     particle_in_polygon(px, py, polygon)

# Description:
# ---
# Determine whether a point is inside a polygon. Note the vertices of the polygon should be  
#     ordered in a **counterclockwise** manner; otherwise, it may lead to incorrect results.  

# (This function is generated by ChatGPT 4o - 2024.10.10)
# """
# @inline Base.@propagate_inbounds function particle_in_polygon(px::T, py::T, polygon) where T
#     n = size(polygon, 1)
#     winding_number = 0
#     tol = 1e-10
#     @inbounds for i in axes(polygon, 1)
#         x1, y1 = polygon[i, :]
#         x2, y2 = polygon[mod1(i + 1, n), :]
        
#         if y1 ≤ py && y2 > py && (x2 - x1) * (py - y1) > (px - x1) * (y2 - y1) + tol
#             winding_number += 1
#         elseif y1 > py && y2 ≤ py && (x2 - x1) * (py - y1) < (px - x1) * (y2 - y1) - tol
#             winding_number -= 1
#         end
#     end
#     return winding_number ≠ 0
# end

"""
    polygon2particle(polygon, lpx, lpy)

Description:
---
Generate structured particles from a given polygon. Note the vertices of the polygon should 
be ordered in a **counterclockwise** manner; otherwise, it may lead to incorrect results.  

`lpx` and `lpy` are the space of particles in `x` and `y` directions, respectively.

`polygon` is the polygon, for example, `polygon = [0 0; 2 0; 2 1; 0 1]` means generate
structured particles in a rectangle area.
"""
@views function polygon2particle(polygon::AbstractMatrix{T}, lpx, lpy) where T<:Real
    # inputs check
    n, m = size(polygon)
    n < 3 && error("polygon should have at least 3 vertices")
    m == 2 || error("polygon should be a Nx2 array")

    # get bounding box for particles
    x_min = minimum(polygon[:, 1])
    x_max = maximum(polygon[:, 1])
    y_min = minimum(polygon[:, 2])
    y_max = maximum(polygon[:, 2])
    offsetx = (x_max - x_min) * 0.2
    offsety = (y_max - y_min) * 0.2
    x_min -= offsetx
    x_max += offsetx
    y_min -= offsety
    y_max += offsety

    # generate structured particles
    mesh = meshbuilder(x_min : lpx : x_max, y_min : lpy : y_max)
    
    # convert to python objects
    py_poly = Polygon(polygon)
    py_points = shapely.points(mesh)
    
    # check if the particle is inside the polygon
    rst = pyconvert(Vector{Bool}, shapely.contains(py_poly, py_points))
    
    return copy(mesh[findall(rst), :])
end

"""
    polygon2particle(stl_file, output_file, h; verbose=true)

Description:
---
Generate structured particles from a given `.stl` file. The particles are generated by
voxelizing the 2D space of the STL model. The voxel size `h` should be positive.
"""
function polygon2particle(stl_file::String, output_file::String, h; verbose::Bool=false)
    @pyexec """
    def py_trimesh_voxelize2d(stl_file, output_file, h, 
        trimesh, np, MultiPolygon, Polygon, Point, mapping, unary_union, rasterio, 
        rasterize, pygmsh, pyKDTree, pytime):
        
        t1_start = pytime.perf_counter()

        # 假设你已经加载了 STL 文件
        mesh = trimesh.load(stl_file)

        # 检查 Z 值是否全为 0
        z_values = mesh.vertices[:, 2]
        if np.allclose(z_values, 0) == False:
            raise ValueError("not a 2D mesh, found non-zero Z value")

        # 提取 2D 顶点（丢弃 Z 坐标）
        vertices_2d = mesh.vertices[:, :2]

        # 获取三角形的面
        faces = mesh.faces

        # 将每个三角形转为 Shapely 的 Polygon 对象
        triangles = []
        for face in faces:
            triangle_coords = vertices_2d[face]
            triangle = Polygon(triangle_coords)
            triangles.append(triangle)

        # 使用 Shapely 的 unary_union 合并所有三角形
        multipolygon = MultiPolygon(triangles)
        merged_polygon = unary_union(multipolygon)

        # 检查结果是否为单一水密多边形
        if isinstance(merged_polygon, Polygon) == False:
            print("合并结果不是单一多边形，可能存在重叠或空洞。")

        print("\033[1;36m[ Info:\033[0m model loaded and checked (2D polygon merged)")

        t1_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t2_start = pytime.perf_counter()

        # 获取多边形的边界框
        minx, miny, maxx, maxy = merged_polygon.bounds

        # 计算栅格的行列数
        nx = int((maxx - minx) / h) + 1
        ny = int((maxy - miny) / h) + 1

        # 定义变换矩阵（从左上角开始，Y 从上到下）
        transform = rasterio.transform.from_origin(minx, maxy, h, h)

        # 栅格化多边形
        raster = rasterize(
            [mapping(merged_polygon)],
            out_shape=(ny, nx),
            transform=transform,
            fill=0,
            all_touched=False,
            dtype=np.uint8
        )

        # 生成网格坐标
        x_coords = np.linspace(minx, maxx, nx)
        y_coords = np.linspace(maxy, miny, ny)
        x_grid, y_grid = np.meshgrid(x_coords, y_coords)

        # 提取内部点的坐标
        inside_mask = raster.astype(bool).ravel()
        points = np.vstack((x_grid.ravel(), y_grid.ravel())).T
        inside_points = points[inside_mask]

        print("\033[1;36m[ Info:\033[0m 2D model is rasterized")

        t2_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t3_start = pytime.perf_counter()
        offset = h * 0.25
        offsets = np.array([[-offset,  offset],
                            [ offset,  offset],
                            [-offset, -offset],
                            [ offset, -offset]])
        pts = np.repeat(inside_points, 4, axis=0) + np.tile(offsets, (len(inside_points), 1))
        pts_num = len(pts)

        print(f"\033[1;36m[ Info:\033[0m filled with {pts_num} particles")

        t3_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t4_start = pytime.perf_counter()
        np.savetxt(output_file, pts, fmt='%.6f', delimiter=' ')
        t4_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t1 = t1_end - t1_start
        t2 = t2_end - t2_start
        t3 = t3_end - t3_start
        t4 = t4_end - t4_start
        t5 = t1 + t2 + t3 + t4

        return [t1, t2, t3, t4, t5]
    """ => py_trimesh_voxelize2d

    pytp = py_trimesh_voxelize2d(stl_file, output_file, h, 
        trimesh, np, MultiPolygon, Polygon, Point, mapping, unary_union, rasterio, 
        rasterize, pygmsh, pyKDTree, pytime)

    tp = pyconvert(Vector, pytp)

    if verbose
        t1, t2, t3, t4, tt = tp[1], tp[2], tp[3], tp[4], tp[5]
        @info """2D polygon
        - load model    : $(@sprintf("%6.2f", t1)) s | $(@sprintf("%6.2f", 100*t1/tt))%
        - rasterize     : $(@sprintf("%6.2f", t2)) s | $(@sprintf("%6.2f", 100*t2/tt))%
        - fill particle : $(@sprintf("%6.2f", t3)) s | $(@sprintf("%6.2f", 100*t3/tt))%
        - write .xy     : $(@sprintf("%6.2f", t4)) s | $(@sprintf("%6.2f", 100*t4/tt))%
        $("-"^36)
        - total time    : $(@sprintf("%6.2f", tt)) s
        """
    end

    return nothing
end

"""
    polygon2particle(stl_file, msh_file, output_file, nid_file, h; verbose=true)

Description:
---
Generate structured particles from a given `.stl` file and `.msh` file. The particles are
generated by voxelizing the 2D space of the STL model. The voxel size `h` should be positive.
"""
function polygon2particle(
    stl_file   ::String, 
    msh_file   ::String, 
    output_file::String,
    nid_file   ::String,
    h; 
    verbose    ::Bool=false
)
    @pyexec """
    def py_trimesh_voxelize2d_msh(stl_file, msh_file, output_file, nid_file, h, 
        trimesh, np, MultiPolygon, Polygon, Point, mapping, unary_union, rasterio, 
        rasterize, pygmsh, pyKDTree, pytime):
        
        t1_start = pytime.perf_counter()

        # 假设你已经加载了 STL 文件
        mesh = trimesh.load(stl_file)

        # 检查 Z 值是否全为 0
        z_values = mesh.vertices[:, 2]
        if np.allclose(z_values, 0) == False:
            raise ValueError("not a 2D mesh, found non-zero Z value")

        # 提取 2D 顶点（丢弃 Z 坐标）
        vertices_2d = mesh.vertices[:, :2]

        # 获取三角形的面
        faces = mesh.faces

        # 将每个三角形转为 Shapely 的 Polygon 对象
        triangles = []
        for face in faces:
            triangle_coords = vertices_2d[face]
            triangle = Polygon(triangle_coords)
            triangles.append(triangle)

        # 使用 Shapely 的 unary_union 合并所有三角形
        multipolygon = MultiPolygon(triangles)
        merged_polygon = unary_union(multipolygon)

        # 检查结果是否为单一水密多边形
        if isinstance(merged_polygon, Polygon) == False:
            print("合并结果不是单一多边形，可能存在重叠或空洞。")

        print("\033[1;36m[ Info:\033[0m model loaded and checked (2D polygon merged)")

        t1_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t2_start = pytime.perf_counter()

        # 获取多边形的边界框
        minx, miny, maxx, maxy = merged_polygon.bounds

        # 计算栅格的行列数
        nx = int((maxx - minx) / h) + 1
        ny = int((maxy - miny) / h) + 1

        # 定义变换矩阵（从左上角开始，Y 从上到下）
        transform = rasterio.transform.from_origin(minx, maxy, h, h)

        # 栅格化多边形
        raster = rasterize(
            [mapping(merged_polygon)],
            out_shape=(ny, nx),
            transform=transform,
            fill=0,
            all_touched=False,
            dtype=np.uint8
        )

        # 生成网格坐标
        x_coords = np.linspace(minx, maxx, nx)
        y_coords = np.linspace(maxy, miny, ny)
        x_grid, y_grid = np.meshgrid(x_coords, y_coords)

        # 提取内部点的坐标
        inside_mask = raster.astype(bool).ravel()
        points = np.vstack((x_grid.ravel(), y_grid.ravel())).T
        inside_points = points[inside_mask]

        print("\033[1;36m[ Info:\033[0m 2D model is rasterized")

        t2_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t3_start = pytime.perf_counter()

        # 初始化 Gmsh 并加载网格文件
        pygmsh.initialize()
        pygmsh.option.setNumber("General.Verbosity", 0)
        pygmsh.open(msh_file)

        # 获取所有 Physical Groups
        physical_groups = pygmsh.model.getPhysicalGroups()

        # 存储 Group 的多边形和包围盒
        group_polygons = {}
        group_bounds = {}

        # 解析每个 Group 并生成多边形及包围盒
        for dim, tag in physical_groups:
            if dim == 2:
                group_name = pygmsh.model.getPhysicalName(dim, tag)
                entities = pygmsh.model.getEntitiesForPhysicalGroup(dim, tag)
                triangles = []
                for entity in entities:
                    element_types, _, node_tags = pygmsh.model.mesh.getElements(dim, entity)
                    if len(element_types) > 0 and element_types[0] == 2:
                        for i in range(len(node_tags[0]) // 3):
                            node_indices = node_tags[0][i*3:(i+1)*3]
                            coords = [pygmsh.model.mesh.getNode(n)[0][:2] for n in node_indices]
                            triangles.append(Polygon(coords))
                if triangles:
                    merged_poly = unary_union(MultiPolygon(triangles))
                    group_polygons[group_name] = merged_poly
                    group_bounds[group_name] = merged_poly.bounds

        # 初始化 nid 为 None
        nid = np.full(len(inside_points), None, dtype=object)

        # 查询每个点所属的 Group
        for i, point in enumerate(inside_points):
            point_geom = Point(point[0], point[1])
            for group_name, bounds in group_bounds.items():
                min_x, min_y, max_x, max_y = bounds
                if min_x <= point[0] <= max_x and min_y <= point[1] <= max_y:
                    if group_polygons[group_name].contains(point_geom):
                        nid[i] = group_name
                        break

        # 处理无属性的点
        has_attr_indices = np.where(nid != None)[0]
        has_attr_points = inside_points[has_attr_indices]
        has_attr_nid = nid[has_attr_indices]

        if len(has_attr_points) > 0:
            tree = pyKDTree(has_attr_points)
            no_attr_indices = np.where(nid == None)[0]
            no_attr_points = inside_points[no_attr_indices]
            if len(no_attr_points) > 0:
                distances, nearest_indices = tree.query(no_attr_points)
                for i, nearest_idx in enumerate(nearest_indices):
                    nid[no_attr_indices[i]] = has_attr_nid[nearest_idx]

        # 关闭 Gmsh
        pygmsh.finalize()

        print("\033[1;36m[ Info:\033[0m physical groups are attached to particles")

        t3_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t4_start = pytime.perf_counter()
        nid = np.repeat(nid, 4)
        offset = h * 0.25
        offsets = np.array([[-offset,  offset],
                            [ offset,  offset],
                            [-offset, -offset],
                            [ offset, -offset]])
        pts = np.repeat(inside_points, 4, axis=0) + np.tile(offsets, (len(inside_points), 1))
        pts_num = len(pts)

        print(f"\033[1;36m[ Info:\033[0m filled with {pts_num} particles")

        t4_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t5_start = pytime.perf_counter()
        np.savetxt(output_file, pts, fmt='%.6f', delimiter=' ')
        np.savetxt(nid_file, nid, fmt='%s', delimiter='\\n')
        t5_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t1 = t1_end - t1_start
        t2 = t2_end - t2_start
        t3 = t3_end - t3_start
        t4 = t4_end - t4_start
        t5 = t5_end - t5_start
        t6 = t1 + t2 + t3 + t4 + t5

        return [t1, t2, t3, t4, t5, t6]
    """ => py_trimesh_voxelize2d_msh

    pytp = py_trimesh_voxelize2d_msh(stl_file, msh_file, output_file, nid_file, h, 
        trimesh, np, MultiPolygon, Polygon, Point, mapping, unary_union, rasterio, 
        rasterize, pygmsh, pyKDTree, pytime)

    tp = pyconvert(Vector, pytp)

    if verbose
        t1, t2, t3, t4, t5, tt = tp[1], tp[2], tp[3], tp[4], tp[5], tp[6]
        @info """2D polygon
        - load model    : $(@sprintf("%6.2f", t1)) s | $(@sprintf("%6.2f", 100*t1/tt))%
        - rasterize     : $(@sprintf("%6.2f", t2)) s | $(@sprintf("%6.2f", 100*t2/tt))%
        - attach nid    : $(@sprintf("%6.2f", t3)) s | $(@sprintf("%6.2f", 100*t3/tt))%
        - fill particle : $(@sprintf("%6.2f", t4)) s | $(@sprintf("%6.2f", 100*t4/tt))%
        - write .xy .nid: $(@sprintf("%6.2f", t5)) s | $(@sprintf("%6.2f", 100*t5/tt))%
        $("-"^36)
        - total time    : $(@sprintf("%6.2f", tt)) s
        """
    end
    return nothing
end