#==========================================================================================+
|        MaterialPointGenerator.jl: Generate structured material particles in Julia        |
+------------------------------------------------------------------------------------------+
|  File Name  : polygon.jl                                                                 |
|  Description: Generate structured mesh in 2D space by a given polygon                    |
|  Programmer : Zenan Huo                                                                  |
|  Start Date : 01/01/2022                                                                 |
|  Affiliation: Risk Group, UNIL-ISTE                                                      |
|  Functions  : 01. particle_in_polygon                                                    |
|               02. polygon2particle                                                       |
+==========================================================================================#

export particle_in_polygon
export polygon2particle

"""
    particle_in_polygon(px, py, polygon)

Description:
---
Determine whether a point is inside a polygon. Note the vertices of the polygon should be  
    ordered in a **counterclockwise** manner; otherwise, it may lead to incorrect results.  

(This function is generated by ChatGPT 4o - 2024.10.10)
"""
function particle_in_polygon(px::T, py::T, polygon) where T
    n = size(polygon, 1)
    winding_number = 0
    tol = 1e-10
    @inbounds for i in 1:n
        x1, y1 = polygon[i, :]
        x2, y2 = polygon[mod1(i + 1, n), :]
        
        if y1 ≤ py && y2 > py && (x2 - x1) * (py - y1) > (px - x1) * (y2 - y1) + tol
            winding_number += 1
        elseif y1 > py && y2 ≤ py && (x2 - x1) * (py - y1) < (px - x1) * (y2 - y1) - tol
            winding_number -= 1
        end
    end
    return winding_number ≠ 0
end

"""
    polygon2particle(polygon, lpx, lpy)

Description:
---
Generate structured particles from a given polygon. Note the vertices of the polygon should 
be ordered in a **counterclockwise** manner; otherwise, it may lead to incorrect results.  

`lpx` and `lpy` are the space of particles in `x` and `y` directions, respectively.

`polygon` is the polygon, for example, `polygon = [0 0; 2 0; 2 1; 0 1]` means generate
structured particles in a rectangle area.
"""
@views function polygon2particle(polygon, lpx, lpy)
    # get bounding box for particles
    x_min = minimum(polygon[:, 1])
    x_max = maximum(polygon[:, 1])
    y_min = minimum(polygon[:, 2])
    y_max = maximum(polygon[:, 2])
    offsetx = (x_max - x_min) * 0.2
    offsety = (y_max - y_min) * 0.2
    x_min -= offsetx
    x_max += offsetx
    y_min -= offsety
    y_max += offsety
    # generate structured particles
    mesh = meshbuilder(x_min : lpx : x_max, y_min : lpy : y_max)
    # check if the particle is inside the polygon
    pts = size(mesh, 1)
    rst = Vector{Bool}(undef, pts) 
    @inbounds Threads.@threads for i in 1:pts
        px = mesh[i, 1]
        py = mesh[i, 2]
        rst[i] = particle_in_polygon(px, py, polygon)
    end
    return copy(mesh[findall(rst), :])
end

"""
    polygon2particle(stl_file, output_file, h; verbose=true)

Description:
---
Generate structured particles from a given `.stl` file. The particles are generated by
voxelizing the 2D space of the STL model. The voxel size `h` should be positive.
"""
function polygon2particle(stl_file::String, output_file::String, h; verbose::Bool=true)
    @pyexec """
    def py_trimesh_voxelize2d(stl_file, output_file, h, 
        trimesh, np, MultiPolygon, Polygon, Point, mapping, unary_union, rasterio, 
        rasterize, pygmsh, pyKDTree, pytime):
        
        t1_start = pytime.perf_counter()

        # 假设你已经加载了 STL 文件
        mesh = trimesh.load(stl_file)

        # 检查 Z 值是否全为 0
        z_values = mesh.vertices[:, 2]
        if np.allclose(z_values, 0) == False:
            raise ValueError("not a 2D mesh, found non-zero Z value")

        # 提取 2D 顶点（丢弃 Z 坐标）
        vertices_2d = mesh.vertices[:, :2]

        # 获取三角形的面
        faces = mesh.faces

        # 将每个三角形转为 Shapely 的 Polygon 对象
        triangles = []
        for face in faces:
            triangle_coords = vertices_2d[face]
            triangle = Polygon(triangle_coords)
            triangles.append(triangle)

        # 使用 Shapely 的 unary_union 合并所有三角形
        multipolygon = MultiPolygon(triangles)
        merged_polygon = unary_union(multipolygon)

        # 检查结果是否为单一水密多边形
        if isinstance(merged_polygon, Polygon) == False:
            print("合并结果不是单一多边形，可能存在重叠或空洞。")

        print("\033[1;36m[ Info:\033[0m model loaded and checked (2D polygon merged)")

        t1_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t2_start = pytime.perf_counter()

        # 获取多边形的边界框
        minx, miny, maxx, maxy = merged_polygon.bounds

        # 计算栅格的行列数
        nx = int((maxx - minx) / h) + 1
        ny = int((maxy - miny) / h) + 1

        # 定义变换矩阵（从左上角开始，Y 从上到下）
        transform = rasterio.transform.from_origin(minx, maxy, h, h)

        # 栅格化多边形
        raster = rasterize(
            [mapping(merged_polygon)],
            out_shape=(ny, nx),
            transform=transform,
            fill=0,
            all_touched=False,
            dtype=np.uint8
        )

        # 生成网格坐标
        x_coords = np.linspace(minx, maxx, nx)
        y_coords = np.linspace(maxy, miny, ny)
        x_grid, y_grid = np.meshgrid(x_coords, y_coords)

        # 提取内部点的坐标
        inside_mask = raster.astype(bool).ravel()
        points = np.vstack((x_grid.ravel(), y_grid.ravel())).T
        inside_points = points[inside_mask]

        print("\033[1;36m[ Info:\033[0m 2D model is rasterized")

        t2_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t3_start = pytime.perf_counter()
        offset = h * 0.25
        offsets = np.array([[-offset,  offset],
                            [ offset,  offset],
                            [-offset, -offset],
                            [ offset, -offset]])
        pts = np.repeat(inside_points, 4, axis=0) + np.tile(offsets, (len(inside_points), 1))
        pts_num = len(pts)

        print(f"\033[1;36m[ Info:\033[0m filled with {pts_num} particles")

        t3_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t4_start = pytime.perf_counter()
        np.savetxt(output_file, pts, fmt='%.6f', delimiter=' ')
        t4_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t1 = t1_end - t1_start
        t2 = t2_end - t2_start
        t3 = t3_end - t3_start
        t4 = t4_end - t4_start
        t5 = t1 + t2 + t3 + t4

        return [t1, t2, t3, t4, t5]
    """ => py_trimesh_voxelize2d

    pytp = py_trimesh_voxelize2d(stl_file, output_file, h, 
        trimesh, np, MultiPolygon, Polygon, Point, mapping, unary_union, rasterio, 
        rasterize, pygmsh, pyKDTree, pytime)

    tp = pyconvert(Vector, pytp)

    if verbose
        t1, t2, t3, t4, tt = tp[1], tp[2], tp[3], tp[4], tp[5]
        @info """2D polygon
        - load model    : $(@sprintf("%6.2f", t1)) s | $(@sprintf("%6.2f", 100*t1/tt))%
        - rasterize     : $(@sprintf("%6.2f", t2)) s | $(@sprintf("%6.2f", 100*t2/tt))%
        - fill particle : $(@sprintf("%6.2f", t3)) s | $(@sprintf("%6.2f", 100*t3/tt))%
        - write .xy     : $(@sprintf("%6.2f", t4)) s | $(@sprintf("%6.2f", 100*t4/tt))%
        $("-"^36)
        - total time    : $(@sprintf("%6.2f", tt)) s
        """
    end

    return nothing
end

"""
    polygon2particle(stl_file, msh_file, output_file, nid_file, h; verbose=true)

Description:
---
Generate structured particles from a given `.stl` file and `.msh` file. The particles are
generated by voxelizing the 2D space of the STL model. The voxel size `h` should be positive.
"""
function polygon2particle(
    stl_file   ::String, 
    msh_file   ::String, 
    output_file::String,
    nid_file   ::String,
    h; 
    verbose    ::Bool=true
)
    @pyexec """
    def py_trimesh_voxelize2d_msh(stl_file, msh_file, output_file, nid_file, h, 
        trimesh, np, MultiPolygon, Polygon, Point, mapping, unary_union, rasterio, 
        rasterize, pygmsh, pyKDTree, pytime):
        
        t1_start = pytime.perf_counter()

        # 假设你已经加载了 STL 文件
        mesh = trimesh.load(stl_file)

        # 检查 Z 值是否全为 0
        z_values = mesh.vertices[:, 2]
        if np.allclose(z_values, 0) == False:
            raise ValueError("not a 2D mesh, found non-zero Z value")

        # 提取 2D 顶点（丢弃 Z 坐标）
        vertices_2d = mesh.vertices[:, :2]

        # 获取三角形的面
        faces = mesh.faces

        # 将每个三角形转为 Shapely 的 Polygon 对象
        triangles = []
        for face in faces:
            triangle_coords = vertices_2d[face]
            triangle = Polygon(triangle_coords)
            triangles.append(triangle)

        # 使用 Shapely 的 unary_union 合并所有三角形
        multipolygon = MultiPolygon(triangles)
        merged_polygon = unary_union(multipolygon)

        # 检查结果是否为单一水密多边形
        if isinstance(merged_polygon, Polygon) == False:
            print("合并结果不是单一多边形，可能存在重叠或空洞。")

        print("\033[1;36m[ Info:\033[0m model loaded and checked (2D polygon merged)")

        t1_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t2_start = pytime.perf_counter()

        # 获取多边形的边界框
        minx, miny, maxx, maxy = merged_polygon.bounds

        # 计算栅格的行列数
        nx = int((maxx - minx) / h) + 1
        ny = int((maxy - miny) / h) + 1

        # 定义变换矩阵（从左上角开始，Y 从上到下）
        transform = rasterio.transform.from_origin(minx, maxy, h, h)

        # 栅格化多边形
        raster = rasterize(
            [mapping(merged_polygon)],
            out_shape=(ny, nx),
            transform=transform,
            fill=0,
            all_touched=False,
            dtype=np.uint8
        )

        # 生成网格坐标
        x_coords = np.linspace(minx, maxx, nx)
        y_coords = np.linspace(maxy, miny, ny)
        x_grid, y_grid = np.meshgrid(x_coords, y_coords)

        # 提取内部点的坐标
        inside_mask = raster.astype(bool).ravel()
        points = np.vstack((x_grid.ravel(), y_grid.ravel())).T
        inside_points = points[inside_mask]

        print("\033[1;36m[ Info:\033[0m 2D model is rasterized")

        t2_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t3_start = pytime.perf_counter()

        # 初始化 Gmsh 并加载网格文件
        pygmsh.initialize()
        pygmsh.option.setNumber("General.Verbosity", 0)
        pygmsh.open(msh_file)

        # 获取所有 Physical Groups
        physical_groups = pygmsh.model.getPhysicalGroups()

        # 存储 Group 的多边形和包围盒
        group_polygons = {}
        group_bounds = {}

        # 解析每个 Group 并生成多边形及包围盒
        for dim, tag in physical_groups:
            if dim == 2:
                group_name = pygmsh.model.getPhysicalName(dim, tag)
                entities = pygmsh.model.getEntitiesForPhysicalGroup(dim, tag)
                triangles = []
                for entity in entities:
                    element_types, _, node_tags = pygmsh.model.mesh.getElements(dim, entity)
                    if len(element_types) > 0 and element_types[0] == 2:
                        for i in range(len(node_tags[0]) // 3):
                            node_indices = node_tags[0][i*3:(i+1)*3]
                            coords = [pygmsh.model.mesh.getNode(n)[0][:2] for n in node_indices]
                            triangles.append(Polygon(coords))
                if triangles:
                    merged_poly = unary_union(MultiPolygon(triangles))
                    group_polygons[group_name] = merged_poly
                    group_bounds[group_name] = merged_poly.bounds

        # 初始化 nid 为 None
        nid = np.full(len(inside_points), None, dtype=object)

        # 查询每个点所属的 Group
        for i, point in enumerate(inside_points):
            point_geom = Point(point[0], point[1])
            for group_name, bounds in group_bounds.items():
                min_x, min_y, max_x, max_y = bounds
                if min_x <= point[0] <= max_x and min_y <= point[1] <= max_y:
                    if group_polygons[group_name].contains(point_geom):
                        nid[i] = group_name
                        break

        # 处理无属性的点
        has_attr_indices = np.where(nid != None)[0]
        has_attr_points = inside_points[has_attr_indices]
        has_attr_nid = nid[has_attr_indices]

        if len(has_attr_points) > 0:
            tree = pyKDTree(has_attr_points)
            no_attr_indices = np.where(nid == None)[0]
            no_attr_points = inside_points[no_attr_indices]
            if len(no_attr_points) > 0:
                distances, nearest_indices = tree.query(no_attr_points)
                for i, nearest_idx in enumerate(nearest_indices):
                    nid[no_attr_indices[i]] = has_attr_nid[nearest_idx]

        # 关闭 Gmsh
        pygmsh.finalize()

        print("\033[1;36m[ Info:\033[0m physical groups are attached to particles")

        t3_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t4_start = pytime.perf_counter()
        nid = np.repeat(nid, 4)
        offset = h * 0.25
        offsets = np.array([[-offset,  offset],
                            [ offset,  offset],
                            [-offset, -offset],
                            [ offset, -offset]])
        pts = np.repeat(inside_points, 4, axis=0) + np.tile(offsets, (len(inside_points), 1))
        pts_num = len(pts)

        print(f"\033[1;36m[ Info:\033[0m filled with {pts_num} particles")

        t4_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t5_start = pytime.perf_counter()
        np.savetxt(output_file, pts, fmt='%.6f', delimiter=' ')
        np.savetxt(nid_file, nid, fmt='%s', delimiter='\\n')
        t5_end = pytime.perf_counter()

        #===================================================================================
        #===================================================================================
        #===================================================================================

        t1 = t1_end - t1_start
        t2 = t2_end - t2_start
        t3 = t3_end - t3_start
        t4 = t4_end - t4_start
        t5 = t5_end - t5_start
        t6 = t1 + t2 + t3 + t4 + t5

        return [t1, t2, t3, t4, t5, t6]
    """ => py_trimesh_voxelize2d_msh

    pytp = py_trimesh_voxelize2d_msh(stl_file, msh_file, output_file, nid_file, h, 
        trimesh, np, MultiPolygon, Polygon, Point, mapping, unary_union, rasterio, 
        rasterize, pygmsh, pyKDTree, pytime)

    tp = pyconvert(Vector, pytp)

    if verbose
        t1, t2, t3, t4, t5, tt = tp[1], tp[2], tp[3], tp[4], tp[5], tp[6]
        @info """2D polygon
        - load model    : $(@sprintf("%6.2f", t1)) s | $(@sprintf("%6.2f", 100*t1/tt))%
        - rasterize     : $(@sprintf("%6.2f", t2)) s | $(@sprintf("%6.2f", 100*t2/tt))%
        - attach nid    : $(@sprintf("%6.2f", t3)) s | $(@sprintf("%6.2f", 100*t3/tt))%
        - fill particle : $(@sprintf("%6.2f", t4)) s | $(@sprintf("%6.2f", 100*t4/tt))%
        - write .xy .nid: $(@sprintf("%6.2f", t5)) s | $(@sprintf("%6.2f", 100*t5/tt))%
        $("-"^36)
        - total time    : $(@sprintf("%6.2f", tt)) s
        """
    end
    return nothing
end