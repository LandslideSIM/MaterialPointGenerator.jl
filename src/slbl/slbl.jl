#==========================================================================================+
|        MaterialPointGenerator.jl: Generate structured material particles in Julia        |
+------------------------------------------------------------------------------------------+
|  File Name  : slbl.jl                                                                    |
|  Description: SLBL implementation                                                        |
|  Programmer : Zenan Huo                                                                  |
|  Start Date : 01/01/2022                                                                 |
|  Affiliation: Risk Group, UNIL-ISTE                                                      |
|  Functions  : 01. getlongwidth                                                           |
|               02. SLBL3D                                                                 |
+==========================================================================================#

export getlongwidth
export SLBL3D

"""
    getlongwidth(points; n_segments::Int=200)

Description:
---
Compute the longest internal axis (diameter) of a 2‑D polygon and the widest internal axis
perpendicular to it. `points` is the vertices list of the polygon, which is generated by the
function `getpolygon` (with order).
The function returns the length of the longest axis, its endpoints, the length of the widest
axis, and its endpoints.

Example:
---
```julia
points = [0.0 0.0; 1.0 0.0; 1.0 1.0; 0.0 1.0]
a, b, c, d, e f = getlongwidth(points)
```
"""
function getlongwidth(points; n_segments::Int=200)
    r, c = size(points)
    c in [2, 3] || throw(ArgumentError("points must be a Nx2/Nx3 array"))
    r > 3 || throw(ArgumentError("points must be a Nx2 array with N > 3"))
    pts = c == 2 ? points : points[:, 1:2]
    pypoints = np.array(pts)

    @pyexec """
    def py_getlongwidth(points_xy, n,
                        Polygon, np, ConvexHull, LineString
    ):
        # 1. 先用凸包+旋转卡壳求长轴 (直径)。
        # 2. 沿长轴均匀 n 个采样点，过每点作垂线，与多边形求交；
        # 取交线段中最长者作为宽轴。

        # Parameters
        # ----------
        # points_xy : ndarray, shape (N,2)
        #     多边形顶点坐标，顺或逆时针均可。
        # n : int, default 200
        #     长轴上的采样数。越大越接近理论最宽，但计算量线性增加。

        # Returns
        # -------
        # a : float             长轴长度
        # b : ndarray (2,2)     长轴端点 [[x1,y1], [x2,y2]]
        # c : float             宽轴长度
        # d : ndarray (2,2)     宽轴端点 [[x3,y3], [x4,y4]]

        pts = np.asarray(points_xy, float)
        if pts.ndim != 2 or pts.shape[1] != 2:
            raise ValueError("points_xy 必须是形状 (N,2) 的数组")

        # ---------- 1. 长轴 via 凸包 + 旋转卡壳 ----------
        hull = pts[ConvexHull(pts).vertices]
        h = len(hull)

        def cross2(a, b):  # z 分量
            return a[0]*b[1] - a[1]*b[0]

        j = 1
        pa = pb = hull[0]
        long_len = 0.0
        for i in range(h):
            i1 = (i + 1) % h
            while True:
                j1 = (j + 1) % h
                if cross2(hull[i1]-hull[i], hull[j1]-hull[i]) > \
                cross2(hull[i1]-hull[i], hull[j]-hull[i]):
                    j = j1
                else:
                    break
            dist = np.linalg.norm(hull[i] - hull[j])
            if dist > long_len:
                long_len, pa, pb = dist, hull[i], hull[j]

        u = (pb - pa) / long_len           # 长轴单位向量
        v = np.array([-u[1], u[0]])        # 垂直单位向量

        # ---------- 2. 构造 Shapely 多边形 ----------
        poly = Polygon(pts).buffer(0)      # buffer(0) 修复可能的无效几何

        # ---------- 3. 采样垂线寻找最宽截线 ----------
        diag = np.linalg.norm(np.ptp(pts, axis=0))
        L = diag * 1.5                     # 截线半长，保证足够穿过多边形

        best_len = -1.0
        best_seg = None
        for t in np.linspace(0, 1, n):
            mid = pa + t * (pb - pa)       # 采样点
            p1, p2 = mid + v * L, mid - v * L
            inter = poly.intersection(LineString([p1, p2]))
            if inter.is_empty:
                continue

            # 根据交集类型提取最长线段
            if inter.geom_type == "LineString":
                cand = inter
            elif inter.geom_type == "MultiLineString":
                cand = max(inter.geoms, key=lambda g: g.length)
            else:  # Point / MultiPoint / 其它 → 没有线段可用
                continue

            if cand.length > best_len:
                best_len, best_seg = cand.length, cand

        # 若采样未得到任何线段（极端退化），退化为投影法
        if best_seg is None:
            proj = pts @ v
            idx_min, idx_max = np.argmin(proj), np.argmax(proj)
            best_seg = LineString([pts[idx_min], pts[idx_max]])
            best_len = best_seg.length

        # ---------- 4. 打包结果 ----------
        a = float(long_len)
        b = np.vstack([pa, pb])
        c = float(best_len)
        d = np.array(best_seg.coords)      # (2,2)

        return a, b, c, d
    """ => py_getlongwidth

    a, b, c, d = py_getlongwidth(pypoints, n_segments, Polygon, np, ConvexHull, LineString)

    return pyconvert(Float64, a), pyconvert(Array, b),
           pyconvert(Float64, c), pyconvert(Array, d)
end

"""
    addmask(pts::AbstractMatrix, h::Real)

Description:
---
- This function generates a bounding box grid based on the current DEM range, and attaches 
them to the corresponding nodes of the grid for easy indexing.  
- The first return value is the coordinates of the entire grid, the second return value is 
the node labels: 1 for internal nodes, 2 for boundary nodes, and 0 for external nodes.  
- The third return value is the number of nodes in the grid along the y-direction.
"""
@views function addmask(pts::AbstractMatrix, h::Real)

    x1, x2 = minimum(pts[:, 1]) - h*2, maximum(pts[:, 1]) + h*2
    y1, y2 = minimum(pts[:, 2]) - h*2, maximum(pts[:, 2]) + h*2

    gridxy = meshbuilder(x1:h:x2, y1:h:y2)
    gridz  = zeros(size(gridxy, 1))

    x1, x2 = minimum(gridxy[:, 1]), maximum(gridxy[:, 1])
    y1, y2 = minimum(gridxy[:, 2]), maximum(gridxy[:, 2])
    ny = Int(div(y2-y1, h) + 1)

    b_id = zeros(Int, size(gridxy, 1))
    @inbounds for i in axes(pts, 1)
        px, py, pz = pts[i, 1], pts[i, 2], pts[i, 3]
        ni = Int(div((px-x1), h)) * ny + Int(div((py-y1), h) + 1)
        b_id[ni] = 1
        gridz[ni] = pz
    end
    v_id = findall(b_id .== 1)
    @inbounds for i in v_id
        if b_id[i+1] == 0 || b_id[i-1] == 0 || b_id[i-ny] == 0 || b_id[i+ny] == 0
            b_id[i] = 2
        end
    end
    grid = Array(hcat(gridxy, gridz))
    return grid, b_id, ny
end

@views function SLBL3D(dem::AbstractMatrix, h::Real, zmax::Real, L::Real)
    size(dem, 2) == 3 || throw(ArgumentError("dem must be a Nx3 array"))
    h > 0 || throw(ArgumentError("h must be positive"))
    zmax ≠ 0 || throw(ArgumentError("zmax cannot be zero"))
    L > 0 || throw(ArgumentError("L must be positive"))

    c = 4 * ((zmax/L) / L) * h * h
    grid_c, b_id, ny = addmask(dem, h)
    grid_p = copy(grid_c)
    v_id = findall(b_id .== 1)
    @info "got mask, c is $(c)"

    if zmax > 0
        iter_c = true; while iter_c
            for i in v_id
                n_u = i + 1
                n_d = i - 1
                n_l = i - ny
                n_r = i + ny

                z_temp = (grid_p[n_u, 3] + grid_p[n_d, 3] +
                        grid_p[n_l, 3] + grid_p[n_r, 3]) * 0.25 - c

                grid_c[i, 3] = z_temp < grid_p[i, 3] ? z_temp : grid_c[i, 3]
            end

            iter_c = maximum(abs.(grid_p[:, 3] .- grid_c[:, 3])) < 1e-4 ? false : true
            grid_p .= grid_c
        end
    else
        iter_c = true; while iter_c
            for i in v_id
                n_u = i + 1
                n_d = i - 1
                n_l = i - ny
                n_r = i + ny

                z_temp = (grid_p[n_u, 3] + grid_p[n_d, 3] +
                          grid_p[n_l, 3] + grid_p[n_r, 3]) * 0.25 - c

                grid_c[i, 3] = z_temp > grid_p[i, 3] ? z_temp : grid_c[i, 3]
            end

            iter_c = maximum(abs.(grid_c[:, 3] .- grid_p[:, 3])) < 1e-4 ? false : true
            grid_p .= grid_c
        end
    end

    vid = findall(b_id .≠ 0)
    return Array(grid_c[vid, :])
end