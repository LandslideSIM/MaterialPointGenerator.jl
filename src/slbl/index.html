<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>SLBL Boundary Selector</title>
<style>
  body{margin:0;padding:20px;background:#1a1a1a;color:#fff;
       display:flex;justify-content:center;align-items:center;min-height:100vh;
       font-family:Arial,Helvetica,sans-serif;}
  .container{display:flex;gap:32px;align-items:flex-start;}
  .controls{display:flex;flex-direction:column;gap:14px;min-width:150px}
  .group{display:flex;flex-direction:column;gap:4px}
  .size-controls{display:flex;gap:6px}
  button{padding:10px 20px;background:#333;color:#fff;border:1px solid #666;border-radius:4px;
         cursor:pointer;transition:background .3s}
  .size-btn{width:60px}
  button:hover{background:#555}
  label{font-size:12px;display:flex;justify-content:space-between}
  input[type=range]{width:100%}
  canvas{border:1px solid #666;background:#2a2a2a}
  .axis-label{position:absolute;font-size:12px;color:#fff}
  .axis-label.y-label{left:-28px;}
  .instructions{position:absolute;color:#888;font-size:12px;white-space:nowrap;
                transform:translateX(-50%);top:25px;left:50%}
</style>
</head>
<body>
<div class="container">
  <!-- -------- 控制区 -------- -->
  <div class="controls">
    <div class="group">
      <label>Point&nbsp;size&nbsp;<span id="sizeValue">1.0</span></label>
      <div class="size-controls">
        <button id="increaseSize" class="size-btn">+</button>
        <button id="decreaseSize" class="size-btn">−</button>
      </div>
    </div>

    <div class="group">
      <label>Azimuth&nbsp;<span id="azVal">315°</span></label>
      <input id="azSlider" type="range" min="0" max="360" value="315">
    </div>
    <div class="group">
      <label>Altitude&nbsp;<span id="altVal">45°</span></label>
      <input id="altSlider" type="range" min="5" max="90" value="45">
    </div>
    <div class="group">
      <label>Exaggeration&nbsp;<span id="exagVal">1.0×</span></label>
      <input id="exagSlider" type="range" min="0.1" max="5" step="0.1" value="1">
    </div>
    <div class="group">
      <label>Contrast&nbsp;γ&nbsp;<span id="gammaVal">1.0</span></label>
      <input id="gammaSlider" type="range" min="0.5" max="2" step="0.1" value="1">
    </div>

    <button id="loadBtn">Load&nbsp;.XYZ</button>
    <button id="clearBtn">Clear&nbsp;polygon</button>
    <button id="saveBtn">Save&nbsp;results</button>
    <input type="file" id="fileInput" hidden accept=".xyz">
  </div>

  <!-- -------- 画布区 -------- -->
  <div style="position:relative">
    <canvas id="canvas"></canvas>
    <div class="axis-label" style="bottom:-20px;left:50%;transform:translateX(-50%)">
      X
      <div class="instructions">Click&nbsp;=&nbsp;select&nbsp;|&nbsp;Enter&nbsp;=&nbsp;finalize&nbsp;|&nbsp;U&nbsp;=&nbsp;undo&nbsp;|&nbsp;Clear&nbsp;=&nbsp;reset</div>
    </div>
    <div class="axis-label y-label" style="top:50%;transform:rotate(-90deg)">Y</div>
  </div>
</div>

<script>
/* ---------- 高分屏处理 ---------- */
const dpr = window.devicePixelRatio || 1;
const LOGICAL_W = 800;   // CSS 像素
const LOGICAL_H = 600;
const canvas    = document.getElementById('canvas');
canvas.style.width  = LOGICAL_W + 'px';
canvas.style.height = LOGICAL_H + 'px';
canvas.width  = LOGICAL_W * dpr;     // 物理像素
canvas.height = LOGICAL_H * dpr;
const ctx = canvas.getContext('2d');

/* ---------- 全局 ---------- */
const MARGIN = 20 * dpr;            // 左 / 下 缩进 (物理像素)
let points=[],polygon=[],grid=new Map();
let scaleX=1,scaleY=1,minX=0,maxX=1,minY=0,maxY=1;
let pointSize=1.0;                  // 逻辑像素
let isFinalized=false,currentSnapPoint=null,baseImage=null;
let azimuthDeg=315, altitudeDeg=45, exaggerationVal=1.0, gammaVal=1.0;
const gridSize=10;                  // 网格（逻辑像素）

/* ---------- 点大小按钮 ---------- */
increaseSize.onclick=()=>{pointSize=Math.min(5,pointSize+0.1);sizeValue.textContent=pointSize.toFixed(1);if(points.length)renderBase();}
decreaseSize.onclick=()=>{pointSize=Math.max(0.1,pointSize-0.1);sizeValue.textContent=pointSize.toFixed(1);if(points.length)renderBase();}

/* ---------- 滑块 ---------- */
const refresh=()=>{if(points.length)renderBase();};
azSlider.oninput=()=>{azimuthDeg=+azSlider.value;azVal.textContent=`${azimuthDeg}°`;refresh();}
altSlider.oninput=()=>{altitudeDeg=+altSlider.value;altVal.textContent=`${altitudeDeg}°`;refresh();}
exagSlider.oninput=()=>{exaggerationVal=+exagSlider.value;exagVal.textContent=`${exaggerationVal.toFixed(1)}×`;refresh();}
gammaSlider.oninput=()=>{gammaVal=+gammaSlider.value;gammaVal.textContent=gammaVal.toFixed(1);refresh();}

/* ---------- 文件加载 ---------- */
loadBtn.onclick=()=>fileInput.click();
fileInput.onchange=async e=>{
  const f=e.target.files[0];if(!f)return;
  parseXYZ(await f.text());renderBase();redraw();
};

/* ---------- 解析 XYZ ---------- */
function parseXYZ(txt){
  points=[];grid.clear();minX=minY=Infinity;maxX=maxY=-Infinity;
  txt.trim().split(/\r?\n/).forEach(l=>{
    const [xs,ys,zs]=l.trim().split(/\s+/);if(!zs)return;
    const x=+xs,y=+ys,z=+zs;points.push({x,y,z});
    minX=Math.min(minX,x);maxX=Math.max(maxX,x);
    minY=Math.min(minY,y);maxY=Math.max(maxY,y);
  });
  scaleX=((LOGICAL_W-2*20)/(maxX-minX||1))*dpr;  // 物理 px / 数据单位
  scaleY=((LOGICAL_H-2*20)/(maxY-minY||1))*dpr;
  points.forEach(p=>{
    p.canvasX=MARGIN+(p.x-minX)*scaleX;          // 物理 px
    p.canvasY=MARGIN+(p.y-minY)*scaleY;
    const key=`${Math.floor(p.canvasX/(gridSize*dpr))},${Math.floor(p.canvasY/(gridSize*dpr))}`;
    (grid.get(key)??grid.set(key,[]).get(key)).push(p);
  });
}

/* ---------- hill‑shade ---------- */
function hillshade(){
  const az=azimuthDeg*Math.PI/180, alt=altitudeDeg*Math.PI/180;
  const sinAlt=Math.sin(alt), cosAlt=Math.cos(alt), maxSearch=5;
  const cell=gridSize*dpr;
  function neighbor(p,dx,dy){
    const gx=Math.floor(p.canvasX/cell),gy=Math.floor(p.canvasY/cell);
    for(let s=1;s<=maxSearch;s++){
      const list=grid.get(`${gx+dx*s},${gy+dy*s}`);if(list?.length){
        return list.reduce((b,q)=>{const d=Math.abs((dx?q.canvasY:q.canvasX)-(dx?p.canvasY:p.canvasX));return d<b.d?{p:q,d}:b;},{p:list[0],d:Infinity}).p;
      }
    }return null;
  }
  points.forEach(p=>{
    const e=neighbor(p,1,0),w=neighbor(p,-1,0),n=neighbor(p,0,-1),s=neighbor(p,0,1);
    if(!(e&&w&&n&&s)){p.shade=128;return;}
    const dzdx=((e.z-w.z)*exaggerationVal)/(e.x-w.x||1e-6);
    const dzdy=((n.z-s.z)*exaggerationVal)/(n.y-s.y||1e-6);
    const slope=Math.atan(Math.hypot(dzdx,dzdy)),aspect=Math.atan2(dzdy,-dzdx);
    let i=Math.max(0,sinAlt*Math.cos(slope)+cosAlt*Math.sin(slope)*Math.cos(az-aspect));
    i=Math.pow(i,gammaVal);p.shade=Math.round(i*255);
  });
}

/* ---------- 底层绘制 ---------- */
function renderBase(){
  hillshade();
  ctx.fillStyle='#2a2a2a';ctx.fillRect(0,0,canvas.width,canvas.height);
  const img=ctx.createImageData(canvas.width,canvas.height),d=img.data;
  const sizePix=pointSize*dpr;
  points.forEach(p=>{
    const bx=Math.round(p.canvasX),by=Math.round(p.canvasY),s=Math.ceil(sizePix);
    for(let dx=-s;dx<=s;dx++)for(let dy=-s;dy<=s;dy++){
      if(Math.hypot(dx,dy)>sizePix)continue;
      const x=bx+dx,y=by+dy;if(x<0||x>=canvas.width||y<0||y>=canvas.height)continue;
      const idx=(y*canvas.width+x)*4;d[idx]=d[idx+1]=d[idx+2]=p.shade;d[idx+3]=255;
    }
  });
  ctx.putImageData(img,0,0);
  drawAxes();
  baseImage=ctx.getImageData(0,0,canvas.width,canvas.height);
}

/* ---------- 坐标轴 ---------- */
function drawAxes(){
  ctx.strokeStyle='#fff';ctx.lineWidth=1*dpr;
  const right=canvas.width-MARGIN,bottom=canvas.height-MARGIN;
  // X 轴
  ctx.beginPath();ctx.moveTo(MARGIN,bottom);ctx.lineTo(right,bottom);ctx.stroke();
  // Y 轴
  ctx.beginPath();ctx.moveTo(MARGIN,0);ctx.lineTo(MARGIN,bottom);ctx.stroke();

  ctx.fillStyle='#fff';ctx.font=`${10*dpr}px Arial`;ctx.textAlign='center';ctx.textBaseline='top';
  const xStep=(right-MARGIN)/10,yStep=bottom/10;
  for(let i=1;i<=10;i++){
    const x=MARGIN+i*xStep;ctx.beginPath();ctx.moveTo(x,bottom+5*dpr);ctx.lineTo(x,bottom);ctx.stroke();
    ctx.fillText((minX+i/10*(maxX-minX)).toFixed(2),x,bottom+7*dpr);
  }
  ctx.textAlign='right';ctx.textBaseline='middle';
  for(let i=1;i<=10;i++){
    const y=bottom-i*yStep;ctx.beginPath();ctx.moveTo(MARGIN-5*dpr,y);ctx.lineTo(MARGIN,y);ctx.stroke();
    ctx.fillText((minY+i/10*(maxY-minY)).toFixed(2),MARGIN-7*dpr,y);
  }
}

/* ---------- 交互 ---------- */
canvas.onmousemove=e=>{
  if(isFinalized)return;
  const r=canvas.getBoundingClientRect();
  currentSnapPoint=nearest((e.clientX-r.left)*dpr,(e.clientY-r.top)*dpr);
  redraw();
};
canvas.onclick=()=>{if(!isFinalized&&currentSnapPoint){polygon.push(currentSnapPoint);redraw();}};
document.onkeydown=e=>{
  if(e.key==='Enter'){isFinalized=true;redraw();}
  if(e.key==='u'&&!isFinalized&&polygon.length){polygon.pop();redraw();}
};
function redraw(){
  if(baseImage)ctx.putImageData(baseImage,0,0);
  if(polygon.length){
    ctx.fillStyle='#ff0000';ctx.strokeStyle=isFinalized?'#00ff00':'#ff4444';ctx.lineWidth=2*dpr;
    polygon.forEach(p=>{ctx.beginPath();ctx.arc(p.canvasX,p.canvasY,5*dpr,0,2*Math.PI);ctx.fill();});
    ctx.beginPath();ctx.moveTo(polygon[0].canvasX,polygon[0].canvasY);polygon.forEach(p=>ctx.lineTo(p.canvasX,p.canvasY));
    if(isFinalized)ctx.closePath();ctx.stroke();}
  if(currentSnapPoint&&!isFinalized){ctx.fillStyle='#44ff44';ctx.beginPath();
    ctx.arc(currentSnapPoint.canvasX,currentSnapPoint.canvasY,3*dpr,0,2*Math.PI);ctx.fill();}
}

/* ---------- Clear ---------- */
clearBtn.onclick=()=>{polygon=[];isFinalized=false;redraw();};

/* ---------- Save 双文件 ---------- */
saveBtn.onclick=()=>{
  if(polygon.length<3){alert('Please draw a complete polygon first');return;}
  const base=prompt('Enter file name (without extension):','output');if(!base)return;
  /* Worker: 找内部点 */
  const worker=new Worker(URL.createObjectURL(new Blob([`
    self.onmessage=e=>{
      const {pts,poly}=e.data,res=[];
      pts.forEach(p=>{if(inPoly(p,poly))res.push(p);});
      self.postMessage(res);
    };
    function inPoly(pt,poly){
      let inside=false;
      for(let i=0,j=poly.length-1;i<poly.length;j=i++){
        const xi=poly[i].x,yi=poly[i].y,xj=poly[j].x,yj=poly[j].y;
        const intersect=((yi>pt.y)!=(yj>pt.y))&&(pt.x<(xj-xi)*(pt.y-yi)/(yj-yi)+xi);
        if(intersect)inside=!inside;
      }
      return inside;
    }
  `],{type:'text/javascript'})));
  worker.postMessage({pts:points,poly:polygon.map(p=>({x:p.x,y:p.y}))});
  worker.onmessage=e=>{
    const xyz=e.data.map(p=>`${p.x/dpr} ${p.y/dpr} ${p.z}`).join('\n'); // 转回逻辑坐标
    saveFile(xyz,`${base}.xyz`);
    const xy=([...polygon,polygon[0]]).map(p=>`${p.x/dpr} ${p.y/dpr}`).join('\n');
    setTimeout(()=>saveFile(xy,`${base}.xy`),400);
  };
};

/* ---------- utils ---------- */
function saveFile(txt,name){const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([txt],{type:'text/plain'}));a.download=name;document.body.appendChild(a);a.click();a.remove();}
function nearest(x,y){
  const cell=gridSize*dpr;const gx=Math.floor(x/cell),gy=Math.floor(y/cell);let best=null,d=Infinity;
  for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){grid.get(`${gx+dx},${gy+dy}`)?.forEach(p=>{const dist=Math.hypot(x-p.canvasX,y-p.canvasY);if(dist<d&&dist<10*dpr){best=p;d=dist;}});}return best;
}
</script>
</body>
</html>
