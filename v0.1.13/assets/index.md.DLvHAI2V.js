import{_ as a,c as t,o as i,az as n}from"./chunks/framework.BgUxWNKU.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"home","hero":{"name":"<font size=6>MaterialPointGenerator.jl</font>","text":null,"tagline":"An efficient structured particle generator for the MPM in Julia","actions":[{"theme":"brand","text":"View on GitHub","link":"https://github.com/LandslideSIM/MaterialPointGenerator.jl"}],"image":{"src":"/assets/logobg.png","alt":"MaterialPointGenerator.jl"}},"features":[{"icon":"🕸️","title":"Structured coordinates","details":"MaterialPointGenerator.jl is used for generating structured (regular) particles for multiple scenarios","link":null},{"icon":"🧠","title":"Complicated 2/3D models","details":"It supports complex 2D and 3D models, even with internal holes, as long as the surface mesh is watertight","link":null},{"icon":"⛰️","title":"Digital elevation model (DEM)","details":"Particle generation from a Digital Elevation Model (DEM) file","link":null},{"icon":"🧩","title":"DEM advanced operations","details":"Automatically interpolate DEM files with support for shape trimming.","link":null}]},"headers":[],"relativePath":"index.md","filePath":"index.md","lastUpdated":null}'),l={name:"index.md"};function s(o,e,r,d,p,h){return i(),t("div",null,e[0]||(e[0]=[n(`<h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h2><p>During the EGU2023 conference, when I presented a high-performance MPM (Material Point Method) solver, I was asked, &quot;How do you discretize the computational model for the MPM?&quot; I didn&#39;t have a clear answer (I didn&#39;t even consider it a problem) because the models were relatively simple and could be generated directly using some straightforward functions. However, as computational models gradually became more complex and diverse, I began to realize that this was indeed a very good question.</p><p>The preprocessing for MPM should not be a computationally intensive task; it should be fast enough. Yet, I couldn&#39;t find a &quot;plug-and-play&quot; generalized code for this purpose. Some literatures have contributed to this issue, and I built upon their work to create a comprehensive and refined julia package.</p><blockquote><p>No parallelization, no problem—5,334,808 particles from an STL file (998,137 triangles) in just 0.6 s Intel(R) Core(TM) i9-10900K CPU @ 3.70GHz</p></blockquote><h2 id="installation" tabindex="-1">Installation <a class="header-anchor" href="#installation" aria-label="Permalink to &quot;Installation&quot;">​</a></h2><p>Just type <code>]</code> in Julia&#39;s <code>REPL</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) Pkg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> add MaterialPointGenerator</span></span></code></pre></div><h2 id="acknowledgement" tabindex="-1">Acknowledgement <a class="header-anchor" href="#acknowledgement" aria-label="Permalink to &quot;Acknowledgement&quot;">​</a></h2><p>This project is sponserd by <a href="https://wp.unil.ch/risk/" target="_blank" rel="noreferrer">Risk Group | Université de Lausanne</a> and <a href="https://www.csc.edu.cn/" target="_blank" rel="noreferrer">China Scholarship Council [中国国家留学基金管理委员会]</a>.</p>`,9)]))}const g=a(l,[["render",s]]);export{u as __pageData,g as default};
