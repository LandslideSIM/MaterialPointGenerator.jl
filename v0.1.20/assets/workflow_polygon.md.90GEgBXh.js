import{_ as o,C as r,c as p,o as h,aA as n,j as s,G as a,a as t,w as l}from"./chunks/framework.B2jYeBrM.js";const d="/MaterialPointGenerator.jl/v0.1.20/assets/image3.BEJ5BXIT.png",T=JSON.parse('{"title":"Polygon","description":"","frontmatter":{},"headers":[],"relativePath":"workflow/polygon.md","filePath":"workflow/polygon.md","lastUpdated":null}'),k={name:"workflow/polygon.md"},g={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""};function m(C,i,f,F,b,E){const e=r("Badge");return h(),p("div",null,[i[16]||(i[16]=n('<h1 id="polygon" tabindex="-1">Polygon <a class="header-anchor" href="#polygon" aria-label="Permalink to &quot;Polygon&quot;">​</a></h1><p>For the two-dimensional polygon model, we consider two cases: 1) simple polygons, which have no holes in their interior, and 2) complex arbitrary polygons.</p><p>For the first scenario, we simply need to input the vertices of the polygon in a counterclockwise order, and then MaterialPointGenerator.jl will automatically generate uniform material points of the specified size within the minimum enclosing rectangle (AABB) of the polygon. It will use the winding number algorithm to determine whether each material point is inside the polygon. This process does not take much time for simple polygons, and we have enabled multithreading by default (make sure to configure the correct number of threads when starting Julia).</p><p>For the second scenario, to support complex polygons in any situation, we need to utilize some preprocessing software. Here, we recommend using <a href="https://gmsh.info" target="_blank" rel="noreferrer">Gmsh</a>, which is not only open-source and powerful but also offers a user-friendly GUI, making it very easy to get started. We first create the model in Gmsh, where we can determine the precision of the triangular mesh according to our needs (there are many tutorials on Gmsh available on YouTube). After that, we export it as a <code>.stl</code> file. While other formats can theoretically be used, we always recommend sticking with the <code>.stl</code> format. Next, you simply need to read this file and specify the grid size (the grid size in MPM simulations), which is very straightforward!</p><h2 id="Simple-2D-model" tabindex="-1">Simple 2D model <a class="header-anchor" href="#Simple-2D-model" aria-label="Permalink to &quot;Simple 2D model {#Simple-2D-model}&quot;">​</a></h2><p>We are preparing to discretize a two-dimensional pentagon, noting that the specified distance is between the material points in both the x and y directions.</p>',6)),s("details",g,[s("summary",null,[i[0]||(i[0]=s("a",{id:"MaterialPointGenerator.polygon2particle-Tuple{Any, Any, Any}",href:"#MaterialPointGenerator.polygon2particle-Tuple{Any, Any, Any}"},[s("span",{class:"jlbinding"},"MaterialPointGenerator.polygon2particle")],-1)),i[1]||(i[1]=t()),a(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[3]||(i[3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">polygon2particle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(polygon, lpx, lpy)</span></span></code></pre></div><p><strong>Description:</strong></p><p>Generate structured particles from a given polygon. Note the vertices of the polygon should be ordered in a <strong>counterclockwise</strong> manner; otherwise, it may lead to incorrect results.</p><p><code>lpx</code> and <code>lpy</code> are the space of particles in <code>x</code> and <code>y</code> directions, respectively.</p><p><code>polygon</code> is the polygon, for example, <code>polygon = [0 0; 2 0; 2 1; 0 1]</code> means generate structured particles in a rectangle area.</p>',5)),a(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>i[2]||(i[2]=[s("a",{href:"https://github.com/LandslideSIM/MaterialPointGenerator.jl/blob/5031ccb603fa77fcdddb05b0a5df38a60a5ce0e7/src/polygon.jl#L43-L55",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i[17]||(i[17]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> polygon </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.55</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> polygon2particle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(polygon, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">223</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">×</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Matrix{Float64}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.03</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0.49</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.08</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0.39</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.08</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0.44</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.08</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0.49</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.08</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0.54</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.13</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0.29</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ⋮</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.98</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0.54</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.03</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0.39</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.03</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0.44</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.03</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0.49</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.08</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0.49</span></span></code></pre></div><p><img src="`+d+'" alt=""></p><h2 id="Arbitrary-2D-model" tabindex="-1">Arbitrary 2D model <a class="header-anchor" href="#Arbitrary-2D-model" aria-label="Permalink to &quot;Arbitrary 2D model {#Arbitrary-2D-model}&quot;">​</a></h2><p>Please use pre-processing tools like Gmsh or MeshLab to ensure that the current mesh is closed in advance.</p>',4)),s("details",c,[s("summary",null,[i[4]||(i[4]=s("a",{id:"MaterialPointGenerator.polygon2particle-Tuple{String, String, Any}",href:"#MaterialPointGenerator.polygon2particle-Tuple{String, String, Any}"},[s("span",{class:"jlbinding"},"MaterialPointGenerator.polygon2particle")],-1)),i[5]||(i[5]=t()),a(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[7]||(i[7]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">polygon2particle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stl_file, output_file, h; verbose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Description:</strong></p><p>Generate structured particles from a given <code>.stl</code> file. The particles are generated by voxelizing the 2D space of the STL model. The voxel size <code>h</code> should be positive.</p>',3)),a(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>i[6]||(i[6]=[s("a",{href:"https://github.com/LandslideSIM/MaterialPointGenerator.jl/blob/5031ccb603fa77fcdddb05b0a5df38a60a5ce0e7/src/polygon.jl#L81-L88",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i[18]||(i[18]=s("h2",{id:"advanced",tabindex:"-1"},[t("Advanced "),s("a",{class:"header-anchor",href:"#advanced","aria-label":'Permalink to "Advanced"'},"​")],-1)),i[19]||(i[19]=s("p",null,"This involves some advanced operations for partitioning the generated material points. There are two ways to achieve this: 1) directly determining whether the current material point is within a specified polygonal area, and 2) using the concept of physical groups in Gmsh to differentiate the model during the meshing phase.",-1)),i[20]||(i[20]=s("p",null,"For the first case, we can utilize a practical function to check if a point is inside the polygon.",-1)),s("details",y,[s("summary",null,[i[8]||(i[8]=s("a",{id:"MaterialPointGenerator.particle_in_polygon-Union{Tuple{T}, Tuple{T, T, Any}} where T",href:"#MaterialPointGenerator.particle_in_polygon-Union{Tuple{T}, Tuple{T, T, Any}} where T"},[s("span",{class:"jlbinding"},"MaterialPointGenerator.particle_in_polygon")],-1)),i[9]||(i[9]=t()),a(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[11]||(i[11]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">particle_in_polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px, py, polygon)</span></span></code></pre></div><p><strong>Description:</strong></p><p>Determine whether a point is inside a polygon. Note the vertices of the polygon should be ordered in a <strong>counterclockwise</strong> manner; otherwise, it may lead to incorrect results.</p><p>(This function is generated by ChatGPT 4o - 2024.10.10)</p>',4)),a(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>i[10]||(i[10]=[s("a",{href:"https://github.com/LandslideSIM/MaterialPointGenerator.jl/blob/5031ccb603fa77fcdddb05b0a5df38a60a5ce0e7/src/polygon.jl#L16-L25",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),i[21]||(i[21]=s("p",null,[t("For the second case, in addition to the "),s("code",null,".stl"),t(" file, we also need to provide a "),s("code",null,".msh"),t(" file.")],-1)),s("details",u,[s("summary",null,[i[12]||(i[12]=s("a",{id:"MaterialPointGenerator.polygon2particle-Tuple{String, String, String, String, Any}",href:"#MaterialPointGenerator.polygon2particle-Tuple{String, String, String, String, Any}"},[s("span",{class:"jlbinding"},"MaterialPointGenerator.polygon2particle")],-1)),i[13]||(i[13]=t()),a(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[15]||(i[15]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">polygon2particle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stl_file, msh_file, output_file, nid_file, h; verbose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Description:</strong></p><p>Generate structured particles from a given <code>.stl</code> file and <code>.msh</code> file. The particles are generated by voxelizing the 2D space of the STL model. The voxel size <code>h</code> should be positive.</p>',3)),a(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>i[14]||(i[14]=[s("a",{href:"https://github.com/LandslideSIM/MaterialPointGenerator.jl/blob/5031ccb603fa77fcdddb05b0a5df38a60a5ce0e7/src/polygon.jl#L229-L236",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})])])}const v=o(k,[["render",m]]);export{T as __pageData,v as default};
